import os
import asyncio
import logging
import json
import sys
from pathlib import Path

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from google.adk.agents import LlmAgent
from google.adk.apps import App
from google.adk.runners import InMemoryRunner
from google.adk.sessions import InMemorySessionService
from google.adk.code_executors import BuiltInCodeExecutor
from google.genai import types
from google.cloud import secretmanager
# Plugins
from google.adk.plugins.bigquery_agent_analytics_plugin import (
    BigQueryLoggerConfig
)
from fixed_bq_plugin import FixedBigQueryPlugin
from config import config

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Observability
from phoenix.otel import register
from openinference.instrumentation.google_adk import GoogleADKInstrumentor

# Initialize tracing
tracer_provider = register(
    project_name=os.getenv("GCP_PROJECT_ID", "local") + "-code-execution-agent",
    endpoint=os.getenv("PHOENIX_COLLECTOR_ENDPOINT", "http://phoenix:6006/v1/traces"),
    set_global_tracer_provider=True
)
GoogleADKInstrumentor().instrument(tracer_provider=tracer_provider)

# Agent Configuration
APP_NAME = "code_execution_agent"
USER_ID = "finopti_user"
SESSION_ID = "session_code" 

# Setup Auth
if hasattr(config, "GOOGLE_API_KEY") and config.GOOGLE_API_KEY:
    os.environ["GOOGLE_API_KEY"] = config.GOOGLE_API_KEY

# Load Manifest
manifest_path = Path(__file__).parent / "manifest.json"
manifest = {}
if manifest_path.exists():
    with open(manifest_path, "r") as f:
        manifest = json.load(f)

# Load Instructions
instructions_path = Path(__file__).parent / "instructions.json"
if instructions_path.exists():
    with open(instructions_path, "r") as f:
        data = json.load(f)
        instruction_str = data.get("instruction", "You are a code execution agent.")
else:
    instruction_str = "You are a code execution agent."

async def run_agent(prompt: str) -> str:
    """Run the agent with the given prompt."""
    try:
        # Re-initialize Agent/App per request to ensure fresh event loop binding
        # This prevents "Future attached to a different loop" errors
        local_code_agent = LlmAgent(
            name=manifest.get("agent_id", "code_execution_agent"),
            model=config.FINOPTIAGENTS_LLM,
            code_executor=BuiltInCodeExecutor(),
            instruction=instruction_str,
            description=manifest.get("description", "Executes Python code.")
        )
        
        # Initialize BigQuery Plugin locally to ensure it binds to current event loop
        bq_config = BigQueryLoggerConfig(
            enabled=os.getenv("BQ_ANALYTICS_ENABLED", "true").lower() == "true",
        )
        bq_plugin = FixedBigQueryPlugin(
            config=bq_config,
            project_id=config.GCP_PROJECT_ID,
            dataset_id=os.getenv("BIGQUERY_DATASET_ID", "finoptiagents"),
            table_id=os.getenv("BIGQUERYAGENTANALYTICSPLUGIN_TABLE_ID", "agent_analytics_log")
        )

        local_app = App(
            name=APP_NAME,
            root_agent=local_code_agent,
            plugins=[bq_plugin]
        )

        async with InMemoryRunner(app=local_app) as runner:
             await runner.session_service.create_session(
                app_name=APP_NAME,
                user_id=USER_ID,
                session_id=SESSION_ID
            )
             
             content = types.Content(role='user', parts=[types.Part(text=prompt)])
             final_response_text = ""
             
             # Run the agent
             async for event in runner.run_async(
                user_id=USER_ID,
                session_id=SESSION_ID,
                new_message=content
             ):
                # Check for executable code parts for logging
                if event.content and event.content.parts:
                    for part in event.content.parts:
                        if part.executable_code:
                            logger.info(f"Agent generated code:\n{part.executable_code.code}")
                        elif part.code_execution_result:
                            logger.info(f"Code output: {part.code_execution_result.output}")

                if event.is_final_response():
                    # Extract text from the final response
                    if event.content and event.content.parts:
                         for part in event.content.parts:
                             if part.text:
                                 final_response_text = part.text
        
        return final_response_text if final_response_text else "No response generated by agent."
        
    except Exception as e:
        logger.error(f"Error running agent: {str(e)}", exc_info=True)
        return f"Error running agent: {str(e)}"

def process_request(prompt: str) -> str:
    """Synchronous wrapper for run_agent."""
    return asyncio.run(run_agent(prompt))
